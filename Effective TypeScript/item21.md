# 타입 넓히기

- 작성하 ㄴ코드를 체크하는 정적 분석 시점에서 `가능한` 값들의 집한인 타입을 가진다.
- 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정 해야한다
  위 말은 `지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유츄`해야 한다는 뜻

> 이를 타입 넓히기 라고 한다

```ts
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
const getComponent = (vector: Vector3, axis: "x" | "y" | "z") => {
  return vector[axis];
};

let x = "x"; // x가 string으로 추론된다
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // 추론된 값이 'x'|'y'|'z'에 할당 될 수 없어서 에러 발생
```

## 넓히기 제어

> 타입스크립트는 타입을 추론할 때 ` 명확성과 유연성` 사이의 균형을 유지하려 한다.
> 타입스크립트는 넓히기의 과정을 제어할 수 있도록 몇가지 방법을 제공한다.

1. const 사용

- 재할당이 불가능하기 때문에 타입스크립트는 `좁은 타입`으로 추론이 가능해진다.
  `!` 객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 `let`으로 할당된 것처럼 다룬다.

```ts
const x = "x"; // 타입이 'x';
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // 정상

// 객체의 경우
const v = {
  x: 1,
};
v.x = 3; // 정상
v.x = "3"; // '3'형식은 number형식에 할당 불가능하여 에러
v.y = 4; // { x: number; } 형식에 'y'속성이 없어서 에러
v.name = "bibi"; // { x: number; } 형식에 'name'속성이 없어서 에러
```

따라서 이러한 부분을 해결하려면 `타입 추론의 강도를 직접 제어`해야함

<b>타입 추론의 강도를 직접 제어하여 기본 동작을 재정의 </b>

1. 명시적 타입 구문 제공

```ts
const v: { x: 1 | 3 | 5 } = { x: 1 }; // 타입이 { x: 1|3|5; }
```

2. 타입 체커에 추가적인 문맥을 제공( 함수의 매개변수로 값을 전달)

3. 단언문 사용 `as const`

- const 단언문과 변수 선언에 쓰이는 let이나 const와 혼동하면 안된다.
- const 단언문은 `타입 공간의 기법`
- 값 뒤어 as const를 작성하면 타입스크립트는 최대한 `좁은 타입`으로 추론
- 쉽게 말해 객체에 `as const`를 사용하면 상수가 된다는 말

```ts
const a1 = [1, 2, 3]; // 타입이 number[]
const a2 = [1, 2, 3] as const; //타입이 readonly [1,2,3]
```
