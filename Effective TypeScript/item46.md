# 타입 선언과 관련된 세 가지 버전 이해

- 라이브러리의 버전
- 타입선언(@types)의 버전
- 타입스크립트의 버전

> 세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없이 보이는 엉뚱한 오류가 발생 할 수 있음

1. 타입스크립트에서 의존성을 사용하는 방식

- 특정 라이브러리는 dependencies로, 타입 정보는 devDependencies로 설치

```
1.  라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않은 경우

    - 타입 선언도 업데이트하여 라이브러리와 버전을 맞춤
    - 보강 기법 또는 타입 선언의 업데이트를 직접 작성

2.  라이브러리보다 타입 선언의 버전이 최신인 경우

    - 라이브러리 버전을 올리거나 타입 선언의 버전을 내리기

3.  프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우

    - 타입스크립트의 최신 버전을 사용
    - 라이브러리 타입 선언의 버전을 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애 버림

4.  @types 의존성이 중복되는 경우

    a. ex) @types/bar가 현재 호환되지 않는 버전의 @types/foo에 의존하는 경우

    - 전역 네임스페이스에 있는 타입 선언 모듈인 경우 중복 문제가 발생
      → 서로 버전이 호환되도록 업데이트

    b. 일부 라이브러리는 자체적으로 타입 선언을 포함(번들링)

    - package.json 의 types 필드가 .d.ts 파일을 가리키도록 되어 있음
    - 버전 불일치 문제를 해결할 수 있지만, 네 가지 부수적인 문제점이 있음
      - 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우(번들된 타입에서는 @types의 버전 선택 불가능)
      - 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존하는 경우(devDependencies에 들어간 의존성을 다른 사용자는 설치할 수 없기 때문)
        → DefinitelyTyped에 타입 선언을 공개하여 타입 선언을 @types로 분리
      - 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우
        → 과거 버전으로 돌아가서 패치 업데이트를 함
      - 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제
```
